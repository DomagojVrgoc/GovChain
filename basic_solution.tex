In this section we describe a basic infrastructure for publishing government data that allows anyone with a single data entry to challenge the veracity of the data in case it was manipulated. We also provide a simple protocol that enables us to increase the trust of the general public in the data provided by the government. We achieve both of these objective without modifying the way that the government currently publishes or stores their data. We start by recapping basic cryptographic primitives we will be using in the remainder of this paper.

\medskip
\noindent{\bf Cryptographic primitives.} The first cryptographic primitive we will be using is that of {\em cryptographic (digital) signature}. Roughly, one can view the digital signature protocol as consisting of the following three components:
\begin{itemize}
\item A pair $(sk,pk)$, where $sk$ is the secret key known only to a user, and used to generate signatures, and $pk$ is the public key is given to everyone in order to verify that a message's signature was indeed signed by the owner of the secret key $sk$.
\item The method $sign(sk,message)$, allowing us to sign the document data using the secret key $sk$.
\item The method $verify(pk,message,sig)$ that allows us to verify if $sig$ is a valid signature of the document $message$ using a secret key corresponding to the public key $pk$.
\end{itemize}
The signature protocol is required to be sound, namely that it verifies correctly, in a sense that $verify(pk,m,sign(sk,m))$ is always true, and that signatures are unforgeable. There are many digital signature schemes in use these days, for more details we refer the reader to \cite{KatzLindell2014}.

The second primitive we will recall is that of {\em cryptographic hash functions}. Roughly speaking, a cryptographic hash function is any function $h$ that takes as input an arbitrary sized document, and produces a fixed size output, can be efficiently computable, and satisfies the following two properties:
\begin{itemize}
\item {\em Hiding.} This means that for any given input $x$, it is infeasible to compute $x$ if the only information we have is the value $h(x)$.\footnote{Strictly speaking, this also includes a random number $r$ coming from a distribution with high min-entropy, and being given $h(r||x)$ instead of $h(x)$.}
\item {\em Collision resistance.} Meaning, that it is infeasible to efficiently find two different values $x$ and $y$, such that $h(x)=h(y)$.
\end{itemize}
Notice that the hiding property allows us to use $h(x)$ as an encrypted digest of our document $x$, since we can not reconstruct $x$ from $h(x)$ alone, and the value $h(x)$ is of fixed size, even for documents $x$ whose size is in TBs. On the other hand, collision resistance ensures that in order to prove to someone who has only $h(x)$ that we have $x$, we need to provide said $x$. One of the most commonly used hash functions today is SHA-256 \cite{sha_standard}. For a more detailed treatment of hash functions we refer the reader to \cite{bitcoinbook}.

\medskip
\noindent{\bf Hash lists and hash trees.}


\medskip
\noindent{\bf Basic steps to gain trust.} Now that we understand the basic data structures that can guarantee immutability of the data, we can show how they can be used to provide compact certificates that no data was manipulated. The basic idea is quite simple: the government will keep on publishing their data as they do at the present, but at the end of each day, they will also publish a compact cryptographic digest of the data they published during that day. Assume that $d_1,d_2,\ldots ,d_n$ is the list of the documents published during one working day. Furthermore, assume that the order in which this list was published is made available in the day's digest. At the end of the day, the government will also create a Merkle tree $MT(d_1,\ldots ,d_n)$, whose leaves are the hash values of these documents, that is, the values $h(d_1),\ldots ,h(d_n)$. At this point, the government publishes $MT(d_1,\ldots ,d_n)$, together with the cryptographic signature of this data corresponding to the public key under which the government agreed to publish their data. The fact that the signature matches the data in the Merkle tree and the government's public key, allows us to easily verify that the data is legitimate, assuming that the government will keep their secret keys safe.

As explained above, anyone who downloads the root of this Merkle tree (requiring a truly minuscule amount of storage), can check whether the data corresponding to that single day was modified by downloading it in the sequence provided by the government, hashing it, and assembling a Merkle tree starting from these hashes. If the Merkle root published by the government does not match the one computed using this method, we can know that the data had been manipulated. Here we assume that the government also makes it public knowledge which method of hashing and Merkle tree assembly they will be using. 

Notice that if we want to be able to detect which particular documents were modified, we would have to guard the entire Merkle tree. The size of this will be in tens of megabytes for a tree coding one million documents when using SHA-256 as the hash function, so one might argue that even this is a reasonable amount of storage needed to pinpoint which particular data had been manipulated. One can further restrict the amount of needed storage by storing fewer layers of the Merkle tree (i.e if one trims the original leaves the size will roughly half), but also losing the granularity at which manipulations can be detected. For instance, if we store the tree up to the next to last level, we can check if one of the two adjacent documents in the list $d_1,\ldots ,d_n$ have been modified, but will not be able to say which one (Figure \ref{fig-trim}). Based on the volume of the published data, the government might also wish to publish these partial trees and sign them, in order to make it easier for a person to store this information.

We can actually do one better by utilizing the same idea that Bitcoin uses to store its blocks \cite{whitepaper}, and encode and/or publish the hash of the previous day's data in the current day's digest. That is, we can create a hash list of the Merkle trees published each day. This would mean that storing one day's Merkle tree would not only assure that the data of that particular day can not be manipulated, but also, it would assure that the data in any of the days previous to this one could not be manipulated.  That is, since each tree would also contain the value of the hash value of the previous day's digest, we can simply follow this chain day after day, and see if any of the hash values do not match. This simple concept is illustrated in Figure \ref{fig-merkle-chain}.


\medskip
\noindent{\bf Guardians and increasing credibility.} 


